{
  "ex-convert": {
    "starterCode": "import torch\nimport numpy as np\n\nnp_arr = np.array([[1, 2, 3], [4, 5, 6]])\n\n# Converta para tensor SEM compartilhar memória\ntensor = ",
    "hints": [
      "Use torch.tensor() em vez de torch.from_numpy()",
      "torch.tensor() sempre faz uma cópia dos dados"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert isinstance(tensor, torch.Tensor), 'Deve ser um tensor PyTorch'",
        "assert tensor.shape == torch.Size([2, 3]), f'Shape incorreto: esperado (2, 3), obtido {tuple(tensor.shape)}'",
        "original_val = np_arr[0, 0]",
        "tensor[0, 0] = 999",
        "assert np_arr[0, 0] == original_val, 'Array original foi modificado! Use torch.tensor() para não compartilhar memória'"
      ]
    },
    "solution": "tensor = torch.tensor(np_arr)"
  },
  "ex-roundtrip": {
    "starterCode": "import torch\nimport numpy as np\n\nt = torch.arange(10, dtype=torch.float32)\n\n# 1. Calcule a média com PyTorch\nmean_pt = t.mean()\nprint('Média (PyTorch):', mean_pt)\n\n# 2. Converta para NumPy\n# 3. Calcule desvio padrão com NumPy\n# 4. Converta de volta para tensor\nstd_tensor = ",
    "hints": [
      "Use .numpy() para converter para NumPy",
      "Use np.std() para calcular o desvio padrão",
      "Use torch.tensor() para converter o resultado de volta",
      "Lembre-se que np.std() retorna um escalar numpy, não um array"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert isinstance(std_tensor, torch.Tensor), 'Resultado deve ser um tensor PyTorch'",
        "expected_std = torch.tensor(t.numpy().std())",
        "assert torch.isclose(std_tensor, expected_std, atol=1e-5), f'Valor incorreto: esperado {expected_std.item():.4f}, obtido {std_tensor.item():.4f}'"
      ]
    },
    "solution": "std_tensor = torch.tensor(t.numpy().std())"
  },
  "ex-safe-modify": {
    "starterCode": "import torch\nimport numpy as np\n\nsource = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\nprint('Source original:', source)\n\n# Crie um tensor e multiplique por 2 SEM modificar source\ndoubled = ",
    "hints": [
      "Primeiro crie uma cópia independente com torch.tensor(source)",
      "Depois multiplique por 2",
      "Não use torch.from_numpy() pois isso compartilha memória"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert isinstance(doubled, torch.Tensor), 'Resultado deve ser um tensor'",
        "assert list(doubled.numpy()) == [2.0, 4.0, 6.0, 8.0, 10.0], f'Valores incorretos: esperado [2,4,6,8,10], obtido {list(doubled.numpy())}'",
        "assert list(source) == [1.0, 2.0, 3.0, 4.0, 5.0], 'Array source foi modificado! Crie uma cópia independente'"
      ]
    },
    "solution": "doubled = torch.tensor(source) * 2"
  },
  "ex-statistics": {
    "starterCode": "import torch\nimport numpy as np\n\ntorch.manual_seed(42)\nscores = torch.randn(1000)\n\n# Converta para NumPy e calcule percentis 10, 50, 90\n# Retorne como tensor PyTorch\npercentiles = ",
    "hints": [
      "Use scores.numpy() para converter para NumPy",
      "Use np.percentile(array, [10, 50, 90]) para calcular os percentis",
      "Use torch.tensor() para converter o resultado de volta"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert isinstance(percentiles, torch.Tensor), 'Resultado deve ser um tensor PyTorch'",
        "assert percentiles.shape == torch.Size([3]), f'Shape incorreto: esperado (3,), obtido {tuple(percentiles.shape)}'",
        "expected = torch.tensor(np.percentile(scores.numpy(), [10, 50, 90]))",
        "assert torch.allclose(percentiles.float(), expected.float(), atol=1e-4), 'Valores dos percentis incorretos'"
      ]
    },
    "solution": "percentiles = torch.tensor(np.percentile(scores.numpy(), [10, 50, 90]))"
  },
  "ex-safe-gpu": {
    "starterCode": "import torch\nimport numpy as np\n\n# Implemente a função safe_to_numpy\ndef safe_to_numpy(tensor):\n    \"\"\"Converte qualquer tensor para NumPy de forma segura.\"\"\"\n    pass  # Substitua isso\n\n# Teste\nt = torch.tensor([1.0, 2.0, 3.0], requires_grad=True)\nresult = safe_to_numpy(t)\nprint('Resultado:', result)\nprint('Tipo:', type(result))",
    "hints": [
      "Use .detach() para remover do grafo de gradientes",
      "Use .cpu() para mover para CPU (necessário se estiver na GPU)",
      "Use .numpy() para converter para array NumPy",
      "A ordem é: tensor.detach().cpu().numpy()"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "import numpy as np",
        "t_test = torch.tensor([1.0, 2.0, 3.0], requires_grad=True)",
        "result_test = safe_to_numpy(t_test)",
        "assert isinstance(result_test, np.ndarray), 'Resultado deve ser um array NumPy'",
        "assert list(result_test) == [1.0, 2.0, 3.0], 'Valores incorretos'"
      ]
    },
    "solution": "def safe_to_numpy(tensor):\n    return tensor.detach().cpu().numpy()"
  }
}
