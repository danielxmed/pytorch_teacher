{
  "ex-2d-tensor": {
    "starterCode": "import torch\n\n# Crie um tensor 2D com shape (3, 4) preenchido com zeros\nx = ",
    "hints": [
      "Use torch.zeros() para criar tensores preenchidos com zeros",
      "O argumento de torch.zeros() pode ser os tamanhos das dimensões: torch.zeros(linhas, colunas)"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert x.shape == torch.Size([3, 4]), f'Shape incorreto: esperado (3, 4), obtido {tuple(x.shape)}'",
        "assert x.sum() == 0, 'O tensor deveria conter apenas zeros'",
        "assert x.dtype == torch.float32, 'O dtype padrão de zeros é float32'"
      ]
    },
    "solution": "x = torch.zeros(3, 4)"
  },
  "ex-random-tensor": {
    "starterCode": "import torch\n\n# Crie um tensor aleatório (distribuição normal) com shape (5, 5)\nrandom_tensor = ",
    "hints": [
      "Use torch.randn() para valores de uma distribuição normal (média 0, desvio padrão 1)",
      "Não confunda torch.rand() (uniforme 0-1) com torch.randn() (normal)"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert random_tensor.shape == torch.Size([5, 5]), f'Shape incorreto: esperado (5, 5), obtido {tuple(random_tensor.shape)}'",
        "assert random_tensor.dtype == torch.float32, 'O dtype deveria ser float32'"
      ]
    },
    "solution": "random_tensor = torch.randn(5, 5)"
  },
  "ex-dtype-conversion": {
    "starterCode": "import torch\n\n# Crie um tensor de inteiros e converta para float32\nint_tensor = torch.tensor([1, 2, 3, 4, 5])\nfloat_tensor = ",
    "hints": [
      "Você pode usar o método .float() para converter para float32",
      "Alternativamente, use .to(torch.float32) ou int_tensor.type(torch.float32)"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert float_tensor.dtype == torch.float32, f'Dtype incorreto: esperado float32, obtido {float_tensor.dtype}'",
        "assert list(float_tensor) == [1.0, 2.0, 3.0, 4.0, 5.0], 'Os valores deveriam ser [1.0, 2.0, 3.0, 4.0, 5.0]'"
      ]
    },
    "solution": "float_tensor = int_tensor.float()"
  },
  "ex-tensor-info": {
    "starterCode": "import torch\n\nt = torch.rand(2, 3, 4)\n\n# Extraia as informações do tensor\nnum_dims = \nnum_elements = \ntensor_dtype = ",
    "hints": [
      "Use .ndim ou len(t.shape) para obter o número de dimensões",
      "Use .numel() para obter o número total de elementos",
      "Use .dtype para obter o tipo de dados"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert num_dims == 3, f'Número de dimensões incorreto: esperado 3, obtido {num_dims}'",
        "assert num_elements == 24, f'Número de elementos incorreto: esperado 24, obtido {num_elements}'",
        "assert tensor_dtype == torch.float32, f'Dtype incorreto: esperado float32, obtido {tensor_dtype}'"
      ]
    },
    "solution": "num_dims = t.ndim\nnum_elements = t.numel()\ntensor_dtype = t.dtype"
  },
  "ex-linspace": {
    "starterCode": "import torch\n\n# Crie um tensor com 11 valores uniformemente espaçados entre 0 e 1\n# Dica: use torch.linspace()\nlinear_space = ",
    "hints": [
      "torch.linspace(start, end, steps) cria 'steps' valores uniformemente espaçados",
      "Para 11 valores entre 0 e 1: torch.linspace(0, 1, 11)",
      "O intervalo inclui tanto o start quanto o end"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert linear_space.shape == torch.Size([11]), f'Shape incorreto: esperado (11,), obtido {tuple(linear_space.shape)}'",
        "assert abs(linear_space[0].item() - 0.0) < 1e-6, 'O primeiro valor deveria ser 0.0'",
        "assert abs(linear_space[-1].item() - 1.0) < 1e-6, 'O último valor deveria ser 1.0'",
        "assert abs(linear_space[5].item() - 0.5) < 1e-6, 'O valor do meio deveria ser 0.5'"
      ]
    },
    "solution": "linear_space = torch.linspace(0, 1, 11)"
  },
  "ex-identity-batch": {
    "starterCode": "import torch\n\n# Crie um batch de 4 matrizes identidade 3x3\n# Shape final: (4, 3, 3)\n# Dica: comece com torch.eye(3), depois adicione dimensão e expanda\nbatch_identity = ",
    "hints": [
      "Primeiro crie uma matriz identidade 3x3 com torch.eye(3)",
      "Use .unsqueeze(0) para adicionar uma dimensão no início: shape (1, 3, 3)",
      "Use .expand(4, -1, -1) ou .repeat(4, 1, 1) para criar 4 cópias",
      "expand() não copia memória, repeat() sim"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert batch_identity.shape == torch.Size([4, 3, 3]), f'Shape incorreto: esperado (4, 3, 3), obtido {tuple(batch_identity.shape)}'",
        "assert torch.all(batch_identity[0] == torch.eye(3)), 'Cada elemento do batch deveria ser uma matriz identidade 3x3'",
        "assert torch.all(batch_identity[1] == torch.eye(3)), 'Cada elemento do batch deveria ser uma matriz identidade 3x3'",
        "assert torch.all(batch_identity[3] == torch.eye(3)), 'Cada elemento do batch deveria ser uma matriz identidade 3x3'"
      ]
    },
    "solution": "batch_identity = torch.eye(3).unsqueeze(0).expand(4, -1, -1)"
  },
  "ex-mask-replace": {
    "starterCode": "import torch\n\n# Substitua todos os valores negativos por seu valor absoluto\ntorch.manual_seed(42)  # Para reprodutibilidade\nt = torch.randn(4, 4)\nprint(\"Tensor original:\\n\", t)\n\n# Crie all_positive onde negativos são substituídos por seu absoluto\nall_positive = ",
    "hints": [
      "Primeiro faça uma cópia do tensor com t.clone()",
      "Use indexação booleana: tensor[tensor < 0] seleciona elementos negativos",
      "torch.abs() ou .abs() retorna o valor absoluto",
      "Alternativa: torch.where(condição, valor_se_true, valor_se_false)"
    ],
    "validation": {
      "type": "assert",
      "tests": [
        "assert all_positive.shape == torch.Size([4, 4]), f'Shape incorreto: esperado (4, 4), obtido {tuple(all_positive.shape)}'",
        "assert torch.all(all_positive >= 0), 'Todos os valores deveriam ser não-negativos'",
        "assert torch.allclose(all_positive, torch.abs(t)), 'all_positive deveria ser igual a torch.abs(t)'"
      ]
    },
    "solution": "all_positive = torch.abs(t)"
  }
}
